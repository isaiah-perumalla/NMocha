//-----------------------------------------------------------------------
// <copyright file="BuildableExpectationTest.cs" company="NMock2">
//
//   http://www.sourceforge.net/projects/NMock2
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
// </copyright>
// This is the easiest way to ignore StyleCop rules on this file, even if we shouldn't use this tag:
// <auto-generated />
//-----------------------------------------------------------------------
using System.IO;
using NMocha;
using NMocha.Internal;
using NMocha.Monitoring;
using NMock2.Matchers;
using NMock2.Monitoring;
using NMock2.Test.Monitoring;
using NUnit.Framework;

namespace NMock2.Internal.Test {
    [TestFixture]
    public class InvocationExpectationTest {
        #region Setup/Teardown

        [SetUp]
        public void SetUp() {
            var mockery = new Mockery();
            receiver = mockery.NewInstanceOfRole<IMockObject>(DefinedAs.Named("receiver"));
            invocation = new Invocation(receiver, new MethodInfoStub("method"), new object[] {"arg"});
        }

        #endregion

        private Invocation invocation;
        private IMockObject receiver;

       

        private void AssertIsActive(IExpectation expectation, string message) {
            Assert.IsTrue(expectation.IsActive, message);
        }

        private void AssertHasBeenMet(IExpectation expectation, string message) {
            Assert.IsTrue(expectation.HasBeenMet, message);
        }

        private void AssertHasNotBeenMet(IExpectation expectation, string message) {
            Assert.IsFalse(expectation.HasBeenMet, message);
        }

        private void AssertIsNotActive(IExpectation expectation, string message) {
            Assert.IsFalse(expectation.IsActive, message);
        }

        private void AssertDescriptionIsEqual(InvocationExpectation expectation, string expected) {
            var writer = new StringDescriptionWriter();
            expectation.DescribeActiveExpectationsTo(writer);

            Assert.AreEqual(expected, writer.ToString());
        }

        [Test]
        public void ChecksCallCountToAssertThatItHasBeenMet() {
          
            var expectation = new InvocationExpectation(Cardinality.AtLeast(2));

            AssertHasNotBeenMet(expectation, "should not have been met after no invocations");

            expectation.Perform(invocation);
            AssertHasNotBeenMet(expectation, "should not have been met after 1 invocation");

            expectation.Perform(invocation);
            AssertHasBeenMet(expectation, "should have been met after 2 invocations");

            expectation.Perform(invocation);
            AssertHasBeenMet(expectation, "should have been met after 3 invocations");

            expectation.Perform(invocation);
            AssertHasBeenMet(expectation, "should have been met after 4 invocations");
        }

        /*[Test]
        public void DoesNotMatchIfAnyMatcherDoesNotMatch() {
            const bool ignoreRequiredCallCount = true;

            for (int i = 1; i < 64; i++)
            {
                InvocationExpectation e = BuildExpectation(
                    ignoreRequiredCallCount,
                    (i & 1) == 0,
                    (i & 2) == 0 ? receiver : null,
                    (i & 4) == 0,
                    (i & 8) == 0,
                    (i & 16) == 0,
                    (i & 32) == 0);

                Assert.IsFalse(e.Matches(invocation), "should not match (iteration " + i + ")");
            }
        }
*/
       /* [Test]
        public void InvokesAListOfActionsToPerformAnInvocation() {
            InvocationExpectation e = BuildExpectation(true, true, receiver, true, true, true, true);
            var action1 = new MockAction();
            var action2 = new MockAction();

            e.AddAction(action1);
            e.AddAction(action2);

            e.Perform(invocation);

            Assert.AreSame(invocation, action1.Received, "action1 received");
            Assert.AreSame(invocation, action2.Received, "action1 received");
        }*/

        /*[Test]
        public void MatchesCallCountWhenMatchingInvocation() {
            Matcher irrelevant = Is.Anything;

            InvocationExpectation expectation = BuildExpectation(
                "description",
                irrelevant,
                Is.AtMost(4),
                receiver,
                irrelevant,
                irrelevant,
                irrelevant,
                irrelevant);

            AssertIsActive(expectation, "should be active before any invocation");
            Assert.IsTrue(expectation.Matches(invocation), "should match 1st invocation");
            expectation.Perform(invocation);

            AssertIsActive(expectation, "should be active before 2nd invocation");
            Assert.IsTrue(expectation.Matches(invocation), "should match 2nd invocation");
            expectation.Perform(invocation);

            AssertIsActive(expectation, "should be active before 3rd invocation");
            Assert.IsTrue(expectation.Matches(invocation), "should match 3rd invocation");
            expectation.Perform(invocation);

            AssertIsActive(expectation, "should be active before 4th invocation");
            Assert.IsTrue(expectation.Matches(invocation), "should match 4th invocation");
            expectation.Perform(invocation);

            AssertIsNotActive(expectation, "should not be active after 4th invocation");
            Assert.IsFalse(expectation.Matches(invocation), "should not match 5th invocation");
        }

        [Test]
        public void MatchesIfAllMatchersMatch() {
            InvocationExpectation e = BuildExpectation(true, true, receiver, true, true, true, true);
            Assert.IsTrue(e.Matches(invocation), "should match");
        }*/
    }

    internal class MockAction : IAction {
        public string Description;
        public MockAction Previous;
        public Invocation Received;

        public MockAction() : this("MockAction") {
        }

        public MockAction(string description) {
            Description = description;
        }

        #region IAction Members

        public void Invoke(Invocation invocation) {
            if (Previous != null) Assert.IsNotNull(Previous.Received, "called out of order");
            Received = invocation;
        }

        public void DescribeOn(IDescription description) {
            description.AppendText(Description);
        }

        #endregion
    }
}