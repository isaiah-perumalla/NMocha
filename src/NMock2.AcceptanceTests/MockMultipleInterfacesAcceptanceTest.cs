//-----------------------------------------------------------------------
// <copyright file="MockMultipleInterfacesAcceptanceTest.cs" company="NMock2">
//
//   http://www.sourceforge.net/projects/NMock2
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
// </copyright>
// This is the easiest way to ignore StyleCop rules on this file, even if we shouldn't use this tag:
// <auto-generated />
//-----------------------------------------------------------------------
using System;
using System.Collections;
using NMocha;
using NMocha.AcceptanceTests;
using NUnit.Framework;

namespace NMock2.AcceptanceTests {
    [TestFixture, CastleOnly]
    public class MockMultipleInterfacesAcceptanceTest : AcceptanceTestBase {
        public interface IHaveAllMemberTypes {
            int this[string key] { get; set; }
            int Value { get; set; }
            event EventHandler SomethingHappened;
            int DoSomething();
        }

        public interface IAmASubclass : IHaveAllMemberTypes {
            int DoSomethingElse();
        }

        public interface IHaveIdenticalMember {
            int DoSomething(); // Same member as on IHaveAllMemberTypes
        }

        public interface IAmGeneric<T> {
            T DoWork(T input);
        }

        public interface IAmAMarkerInterface {
        }

        public abstract class SomeBase {
            public abstract string GetName();

            public virtual int GetSerialNumber() {
                return 123;
            }
        }

        public abstract class SomeOtherClass {
        }

        private void AssertExpectationsCanBeSet(IHaveAllMemberTypes mock) {
            // Setup expectations
            Expect.Once.On(mock).SetProperty("Value");
            Expect.Once.On(mock).GetProperty("Value").Will(Return.Value(1));
            Expect.Once.On(mock).Set["A"].To(Is.Anything);
            Expect.Once.On(mock).Get["A"].Will(Return.Value(2));
            Expect.Once.On(mock).Message("DoSomething").Will(Return.Value(3));

            // Invoke members on mock and validate what we can
            mock.Value = 0;
            Assert.AreEqual(1, mock.Value);
            mock["A"] = 0;
            Assert.AreEqual(2, mock["A"]);
            Assert.AreEqual(3, mock.DoSomething());
        }

        private void AssertExpectationsCanBeSet(IAmASubclass mock) {
            Expect.Once.On(mock).Message("DoSomethingElse").Will(Return.Value(4));

            Assert.AreEqual(4, mock.DoSomethingElse());
        }

        private void AssertExpectationsCanBeSet(IEnumerable mock) {
            IEnumerator enumerator = new ArrayList().GetEnumerator();
            Expect.Once.On(mock).Message("GetEnumerator").Will(Return.Value(enumerator));

            Assert.AreSame(enumerator, mock.GetEnumerator());
        }

        [Test]
        public void CanMockASingleClassTypeAsAnAdditionalType() {
            var mock =
                Mockery.NewInstanceOfRole<IEnumerable>(DefinedAs.Implementing(typeof (IHaveAllMemberTypes),
                                                                            typeof (SomeBase)));

            AssertExpectationsCanBeSet(mock);
            AssertExpectationsCanBeSet(mock as IHaveAllMemberTypes);

            Expect.Once.On(mock).Message("GetName").Will(Return.Value("AAA"));
            Assert.AreSame("AAA", (mock as SomeBase).GetName());
        }


        [Test]
        public void CanMockClassAndInterfaces() {
            var mock =
                Mockery.NewInstanceOfRole<SomeBase>(DefinedAs.Implementing(typeof (IEnumerable),
                                                                         typeof (IHaveAllMemberTypes)));

            AssertExpectationsCanBeSet(mock as IEnumerable);
            AssertExpectationsCanBeSet(mock as IHaveAllMemberTypes);

            Expect.Once.On(mock).Message("GetName").Will(Return.Value("AAA"));
            Assert.AreSame("AAA", mock.GetName());
        }

        [Test]
        public void CanMockEmptyMarkerInterfaces() {
            var mock = Mockery.NewInstanceOfRole<IEnumerable>(DefinedAs.Implementing<IAmAMarkerInterface>());

            Assert.IsInstanceOfType(typeof (IEnumerable), mock);
            Assert.IsInstanceOfType(typeof (IAmAMarkerInterface), mock);
        }

        [Test]
        public void CanMockInheritedInterfaces() {
            var mock = Mockery.NewInstanceOfRole<IEnumerable>(DefinedAs.Implementing<IAmASubclass>());

            AssertExpectationsCanBeSet(mock);
            AssertExpectationsCanBeSet(mock as IHaveAllMemberTypes);
            AssertExpectationsCanBeSet(mock as IAmASubclass);
        }

        [Test]
        public void CanMockMultipleInterfaces() {
            var mock = Mockery.NewInstanceOfRole<IEnumerable>(DefinedAs.Implementing<IHaveAllMemberTypes>());

            AssertExpectationsCanBeSet(mock);
            AssertExpectationsCanBeSet(mock as IHaveAllMemberTypes);
        }

        [Test,
         Ignore(
             "This is an unlikely scenario. Is is mostly harmless and would have negative perf implications if fixed.")]
        public void DuplicateInheritedInterfacesAreIgnored() {
            var mock = Mockery.NewInstanceOfRole<IAmASubclass>(DefinedAs.Implementing<IHaveAllMemberTypes>());
            var otherMock = Mockery.NewInstanceOfRole<IAmASubclass>();

            Assert.AreEqual(mock.GetType(), otherMock.GetType());
        }

        [Test]
        public void DuplicateInterfacesAreIgnored() {
            var mock =
                Mockery.NewInstanceOfRole<IHaveAllMemberTypes>(DefinedAs.Implementing(typeof (IHaveAllMemberTypes),
                                                                                    typeof (IHaveAllMemberTypes)));
            var otherMock = Mockery.NewInstanceOfRole<IHaveAllMemberTypes>(DefinedAs.Implementing<IHaveAllMemberTypes>());

            AssertExpectationsCanBeSet(mock);
            Assert.AreEqual(mock.GetType(), otherMock.GetType(), "Mocks were not of the same runtime type");
        }

        [Test, ExpectedException(typeof (ArgumentException))]
        public void MockingAClassAsAnAdditionalTypeWhenAlreadyMockingAClassThrowsArgumentException() {
            var mock =
                Mockery.NewInstanceOfRole<SomeBase>(DefinedAs.Implementing(typeof (IEnumerable), typeof (SomeOtherClass)));
        }

        [Test, ExpectedException(typeof (ArgumentException))]
        public void MockingMultipleClassesAsAdditionalTypesThrowsArgumentException() {
            var mock =
                Mockery.NewInstanceOfRole<IEnumerable>(DefinedAs.Implementing(typeof (SomeBase), typeof (SomeOtherClass)));
        }

        [Test]
        public void OrderOfInterfacesIsIgnored() {
            var mock =
                Mockery.NewInstanceOfRole<IEnumerable>(DefinedAs.Implementing(typeof (IDisposable),
                                                                            typeof (IHaveAllMemberTypes)));
            var otherMock =
                Mockery.NewInstanceOfRole<IDisposable>(DefinedAs.Implementing(typeof (IHaveAllMemberTypes),
                                                                            typeof (IEnumerable)));

            Assert.AreEqual(mock.GetType(), otherMock.GetType());
        }
    }
}