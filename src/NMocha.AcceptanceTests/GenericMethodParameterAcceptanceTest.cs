//-----------------------------------------------------------------------
// <copyright file="GenericMethodParameterAcceptanceTest.cs" company="NMock2">
//
//   http://www.sourceforge.net/projects/NMock2
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
// </copyright>
// This is the easiest way to ignore StyleCop rules on this file, even if we shouldn't use this tag:
// <auto-generated />
// This is the easiest way to ignore StyleCop rules on this file, even if we shouldn't use this tag:
// <auto-generated />
//-----------------------------------------------------------------------
using System.Collections;
using NMock2;
using NUnit.Framework;

namespace NMocha.AcceptanceTests {
    /// <summary>
    /// Tests for generic method parameters and return values.
    /// <see cref="GenericMethodTypeParamAcceptanceTest"/> for acceptance tests about
    /// generic type parameters.
    /// </summary>
    /// <remarks>
    /// Created on user request for Generic return types.
    /// Request was fed by Adrian Krummenacher on 18-JAN-2008.
    /// </remarks>
    [TestFixture]
    public class GenericMethodParameterAcceptanceTest : AcceptanceTestBase {
        public interface IServiceOne {
            string ServiceOneGetsName();
        }

        public interface IServiceTwo {
            bool ServiceTwoSaves();
        }

        public interface ILocator {
            Hashtable Instances { get; }
            void Register<T>(T instance);
            T Get<T>();
        }

        public abstract class Locator : ILocator {
            #region ILocator Members

            public abstract Hashtable Instances { get; }
            public abstract void Register<T>(T instance);
            public abstract T Get<T>();

            #endregion
        }


        private class PersistentClass {
            private int integerValue;
            private string stringValue;

            public PersistentClass(int integerValue, string stringValue) {
                this.integerValue = integerValue;
                this.stringValue = stringValue;
            }
        }

        private PersistentClass CreatePersistentObject() {
            return new PersistentClass(23, "Persistent string");
        }

        private void AssertCanMockGenericMethod(ILocator locatorMock) {
            var serviceOneMock = Mockery.NewInstanceOfRole<IServiceOne>();
            var serviceTwoMock = Mockery.NewInstanceOfRole<IServiceTwo>();

            // That works only with Expect and if the order of calls to Get match the order of the expectations:
            Expect.Once.On(locatorMock).Message("Get").Will(Return.Value(serviceOneMock));
            Expect.Once.On(locatorMock).Message("Get").Will(Return.Value(serviceTwoMock));

            Expect.Once.On(serviceOneMock).Message("ServiceOneGetsName").Will(Return.Value("ServiceOne"));
            Expect.Once.On(serviceTwoMock).Message("ServiceTwoSaves").Will(Return.Value(true));

            // real call now; only works in same order as the expectations
            var serviceOne = locatorMock.Get<IServiceOne>();
            string name = serviceOne.ServiceOneGetsName();
            Assert.AreEqual("ServiceOne", name, "Service one returned wrong name.");

            var serviceTwo = locatorMock.Get<IServiceTwo>();
            bool res = serviceTwo.ServiceTwoSaves();
            Assert.AreEqual(true, res, "Service two returned wrong boolean value.");
        }

        public void AssertCanMockGenericMethodWithGenericParameter(IGenericSpeaker genericMock) {
            const bool expectedSaveResult = true;
            PersistentClass persistentObject = CreatePersistentObject();

            Expect.Once.On(genericMock).Message("Save").With(persistentObject).Will(Return.Value(expectedSaveResult));

            bool saveResult = genericMock.Save(persistentObject);
            Assert.AreEqual(expectedSaveResult, saveResult,
                            "Generic method 'Save' with PersistentClass did not return correct value.");
        }

        private void AssertCanMockGenericMethodWithGenericParameterUsingValueType(IGenericSpeaker genericMock) {
            const bool expectedSaveResult = true;
            const decimal decimalValue = 13.5m;

            Expect.Once.On(genericMock).Message("Save").With(decimalValue).Will(Return.Value(expectedSaveResult));

            bool saveResult = genericMock.Save(decimalValue);
            Assert.AreEqual(expectedSaveResult, saveResult,
                            "Generic method 'Save' with decimal value did not return correct value.");
        }

        private void AssertCanMockGenericMethodWithGenericReturnValueUsingMixedTypes(IGenericSpeaker genericMock) {
            const int integerValue = 12;
            const string stringValue = "Hello World";

            Expect.Once.On(genericMock).Message("Find").Will(Return.Value(integerValue));
            Expect.Once.On(genericMock).Message("Find").Will(Return.Value(stringValue));

            var integerFindResult = genericMock.Find<int>();
            Assert.AreEqual(integerValue, integerFindResult,
                            "Generic method did not return correct Value Type value.");

            var stringFindResult = genericMock.Find<string>();
            Assert.AreEqual(stringValue, stringFindResult,
                            "Generic method did not return correct Reference Type value.");
        }

        public void AssertCanMockGenericMethodWithGenericReturnValueUsingReferenceType(IGenericSpeaker genericMock) {
            const string stringValue = "Hello World";

            Expect.Once.On(genericMock).Message("Find").Will(Return.Value(stringValue));

            var findResult = genericMock.Find<string>();
            Assert.AreEqual(stringValue, findResult, "Generic method did not return correct Reference Type value.");
        }

        private void AssertCanMockGenericMethodWithGenericReturnValueUsingValueType(IGenericSpeaker genericMock) {
            const int integerValue = 12;

            Expect.Once.On(genericMock).Message("Find").Will(Return.Value(integerValue));

            var findResult = genericMock.Find<int>();
            Assert.AreEqual(integerValue, findResult, "Generic method did not return correct Value Type value.");
        }

        private void AssertCanMockGenericMethodWithMixedParameters(IGenericSpeaker genericMock) {
            string variableA = "Contents of variable a";
            string variableB = "Contents of variable b";
            Expect.Once.On(genericMock).Message("SetVariable").With("A", "Contents of variable a");
            Expect.Once.On(genericMock).Message("SetVariable").With("B", "Contents of variable b");
            Expect.Once.On(genericMock).Message("ReadVariable").With("A").Will(Return.Value(variableA));
            Expect.Once.On(genericMock).Message("ReadVariable").With("B").Will(Return.Value(variableB));

            genericMock.SetVariable("A", "Contents of variable a");
            var resultA = genericMock.ReadVariable<string>("A");
            Assert.AreEqual("Contents of variable a", resultA, "Variable 'A' was not read correctly.");

            genericMock.SetVariable("B", "Contents of variable b");
            var resultB = genericMock.ReadVariable<string>("B");
            Assert.AreEqual("Contents of variable b", resultB, "Variable 'B' was not read correctly.");
        }

        [Test, Class]
        public void CanMockGenericMethodOnClass() {
            AssertCanMockGenericMethod(Mockery.NewInstanceOfRole<Locator>());
        }

        [Test]
        public void CanMockGenericMethodOnInterface() {
            AssertCanMockGenericMethod(Mockery.NewInstanceOfRole<ILocator>());
        }

        [Test, Class]
        public void CanMockGenericMethodWithGenericParameterOnClass() {
            AssertCanMockGenericMethodWithGenericParameter(Mockery.NewInstanceOfRole<GenericSpeaker>());
        }

        [Test]
        public void CanMockGenericMethodWithGenericParameterOnInterface() {
            AssertCanMockGenericMethodWithGenericParameter(Mockery.NewInstanceOfRole<IGenericSpeaker>());
        }

        [Test, Class]
        public void CanMockGenericMethodWithGenericParameterUsingValueTypeOnClass() {
            AssertCanMockGenericMethodWithGenericParameterUsingValueType(Mockery.NewInstanceOfRole<GenericSpeaker>());
        }

        [Test]
        public void CanMockGenericMethodWithGenericParameterUsingValueTypeOnInterface() {
            AssertCanMockGenericMethodWithGenericParameterUsingValueType(Mockery.NewInstanceOfRole<IGenericSpeaker>());
        }

        [Test, Class]
        public void CanMockGenericMethodWithGenericReturnValueUsingMixedTypesOnClass() {
            AssertCanMockGenericMethodWithGenericReturnValueUsingMixedTypes(Mockery.NewInstanceOfRole<GenericSpeaker>());
        }

        [Test]
        public void CanMockGenericMethodWithGenericReturnValueUsingMixedTypesOnInterface() {
            AssertCanMockGenericMethodWithGenericReturnValueUsingMixedTypes(Mockery.NewInstanceOfRole<IGenericSpeaker>());
        }

        [Test, Class]
        public void CanMockGenericMethodWithGenericReturnValueUsingReferenceTypeOnClass() {
            AssertCanMockGenericMethodWithGenericReturnValueUsingReferenceType(
                Mockery.NewInstanceOfRole<GenericSpeaker>());
        }

        [Test]
        public void CanMockGenericMethodWithGenericReturnValueUsingReferenceTypeOnInterface() {
            AssertCanMockGenericMethodWithGenericReturnValueUsingReferenceType(
                Mockery.NewInstanceOfRole<IGenericSpeaker>());
        }

        [Test, Class]
        public void CanMockGenericMethodWithGenericReturnValueUsingValueTypeOnClass() {
            AssertCanMockGenericMethodWithGenericReturnValueUsingValueType(Mockery.NewInstanceOfRole<GenericSpeaker>());
        }

        [Test]
        public void CanMockGenericMethodWithGenericReturnValueUsingValueTypeOnInterface() {
            AssertCanMockGenericMethodWithGenericReturnValueUsingValueType(Mockery.NewInstanceOfRole<IGenericSpeaker>());
        }

        [Test, Class]
        public void CanMockGenericMethodWithMixedParametersOnClass() {
            AssertCanMockGenericMethodWithMixedParameters(Mockery.NewInstanceOfRole<GenericSpeaker>());
        }

        [Test]
        public void CanMockGenericMethodWithMixedParametersOnInterface() {
            AssertCanMockGenericMethodWithMixedParameters(Mockery.NewInstanceOfRole<IGenericSpeaker>());
        }
    }
}